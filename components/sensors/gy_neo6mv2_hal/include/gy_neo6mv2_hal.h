/* components/sensors/gy_neo6mv2_hal/include/gy_neo6mv2_hal.h */

/* GY-NEO6MV2 HAL (Hardware Abstraction Layer) Header File
 * This file provides the interface for interacting with the GY-NEO6MV2 GPS module.
 * The GY-NEO6MV2 is a GPS receiver module that communicates over UART with the ESP32.
 * This header file defines the functions, constants, structures, and enumerations
 * required to control and read data from the GY-NEO6MV2 GPS module.
 *
 *******************************************************************************
 *
 *     +-----------------------+
 *     |      GY-NEO6MV2       |
 *     |-----------------------|
 *     | VCC  | 3.3V or 5V     |----------> VCC
 *     | GND  | Ground         |----------> GND
 *     | TXD  | UART TX        |----------> GPIO_NUM_17
 *     | RXD  | UART RX        |----------> GPIO_NUM_16
 *     +-----------------------+
 *
 *     Block Diagram for Wiring
 *
 *     +----------------------------------------------------+
 *     |                  GY-NEO6MV2 GPS                    |
 *     |                                                    |
 *     |   +----------------+    +-------------------+      |
 *     |   | GPS Receiver   |--->| Signal Processing |      |
 *     |   | Antenna        |    | Unit              |      |
 *     |   +----------------+    +-------------------+      |
 *     |                                                    |
 *     |   +------------------+                             |
 *     |   | UART Interface   |<----------------------------|
 *     |   | (TX, RX)         |                             |
 *     |   +------------------+                             |
 *     |                                                    |
 *     |   +------------------+                             |
 *     |   | Power Supply Unit|                             |
 *     |   | (PSU)            |                             |
 *     |   +------------------+                             |
 *     +----------------------------------------------------+
 *
 *     Internal Structure
 *
 ******************************************************************************/

#ifndef TOPOROBO_GY_NEO6MV2_HAL_H
#define TOPOROBO_GY_NEO6MV2_HAL_H

#include <stdint.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "esp_err.h"
#include "driver/uart.h"

/* Constants ******************************************************************/

/**
 * @brief Logging tag for GY-NEO6MV2 messages.
 *
 * This constant is used as a tag for all ESP_LOG messages generated by the
 * GY-NEO6MV2 driver functions. It allows easy identification of logs related to
 * the GPS module, which is useful for debugging and monitoring the operation
 * of the module.
 */
extern const char *gy_neo6mv2_tag;

/**
 * @brief GPIO pin for UART TX.
 *
 * This constant represents the GPIO pin number used for the UART TX line
 * connected to the GY-NEO6MV2 module. This pin transmits data from the ESP32
 * to the GPS module.
 */
extern const uint8_t gy_neo6mv2_tx_io;

/**
 * @brief GPIO pin for UART RX.
 *
 * This constant represents the GPIO pin number used for the UART RX line
 * connected to the GY-NEO6MV2 module. This pin receives data from the GPS module.
 */
extern const uint8_t gy_neo6mv2_rx_io;

/**
 * @brief UART number used for GY-NEO6MV2 communication.
 *
 * This constant defines the UART number on the ESP32 that is used to
 * communicate with the GY-NEO6MV2 GPS module.
 */
extern const uart_port_t gy_neo6mv2_uart_num;

/**
 * @brief UART baud rate for GY-NEO6MV2 communication.
 *
 * The GY-NEO6MV2 module communicates with the ESP32 at a baud rate of 9600.
 * This constant defines the speed of data transmission over the UART channel.
 */
extern const uint32_t gy_neo6mv2_uart_baudrate;

/**
 * @brief Polling rate for reading data from the GY-NEO6MV2 GPS module in system ticks.
 *
 * This constant defines the interval between consecutive reads of the GPS module.
 * It is expressed in FreeRTOS system ticks to ensure accurate timing and efficient
 * scheduling of GPS data reads.
 */
extern const uint32_t gy_neo6mv2_polling_rate_ticks;

/**
 * @brief Maximum number of retry attempts for module reinitialization.
 *
 * This constant sets the maximum number of consecutive retry attempts that
 * the system will make to reinitialize the GY-NEO6MV2 module in case of an error.
 * After reaching this limit, the retry interval is doubled as part of the
 * exponential backoff strategy. This allows the system to gracefully handle
 * intermittent module failures without continuously retrying.
 */
extern const uint8_t gy_neo6mv2_max_retries;

/**
 * @brief Initial interval between retry attempts in seconds, converted to ticks.
 *
 * This constant defines the initial interval between retry attempts when the
 * GY-NEO6MV2 module encounters an error. The interval is used in the exponential
 * backoff strategy, doubling after each set of `gy_neo6mv2_max_retries` attempts,
 * up to a maximum defined by `gy_neo6mv2_max_backoff_interval`. This strategy
 * prevents excessive retries in quick succession, providing the module time to recover.
 */
extern const uint32_t gy_neo6mv2_initial_retry_interval;

/**
 * @brief Maximum interval for exponential backoff between retries in seconds, converted to ticks.
 *
 * This constant defines the upper limit for the retry interval in the
 * exponential backoff mechanism. Once this maximum is reached, the interval
 * will no longer double, ensuring that retry attempts are eventually spaced
 * far enough apart to prevent frequent reinitialization. This helps to avoid
 * unnecessary load on the system while ensuring the GPS module can recover when possible.
 */
extern const uint32_t gy_neo6mv2_max_backoff_interval;


/* Macros *********************************************************************/

/**
 * @brief Maximum size of the buffer used for storing NMEA sentences from the GY-NEO6MV2 GPS module.
 *
 * This constant defines the maximum number of characters that can be stored in the buffer
 * used for processing NMEA sentences received from the GPS module. It is crucial to choose
 * an appropriate size to accommodate the longest expected NMEA sentence, including the
 * null terminator. Setting a sufficient buffer size prevents potential buffer overflows
 * during sentence processing.
 *
 * A larger buffer size provides more flexibility for handling longer sentences but consumes
 * more memory. A smaller buffer size saves memory but risks truncating longer sentences,
 * potentially leading to incorrect data interpretation or parsing errors. The chosen
 * size should balance memory usage and sentence length requirements.
 */
#define gy_neo6mv2_sentence_buffer_size (128)

/**
 * @brief Maximum number of satellites to store in the buffer.
 *
 * This constant defines the limit for how many satellites' data can be retained at once.
 * It ensures we don't exceed memory limits or process unnecessary data.
 */
#define gy_neo6mv2_max_satellites (32)

/* Enums **********************************************************************/

/**
 * @enum gy_neo6mv2_states_t
 * @brief Represents the operational states of the GY-NEO6MV2 GPS module.
 *
 * This enumeration defines the different states the GPS module can be in,
 * allowing for efficient state tracking and error handling within the system.
 * Each state corresponds to a specific condition or phase of the module's operation.
 */
typedef enum {
  k_gy_neo6mv2_ready         = 0x00, /**< Module is initialized and ready. */
  k_gy_neo6mv2_data_updated  = 0x01, /**< New GPS data has been successfully read. */
  k_gy_neo6mv2_uninitialized = 0x10, /**< Module is not yet initialized. */
  k_gy_neo6mv2_error         = 0xF0, /**< A general error has occurred. */
} gy_neo6mv2_states_t;

/* Structs ********************************************************************/

/**
 * @struct gy_neo6mv2_data_t
 * @brief Structure to store GPS data read from the GY-NEO6MV2 module.
 *
 * This structure holds GPS data such as latitude, longitude, speed, and UTC time.
 * It also maintains diagnostic information including the fix status, number of satellites, 
 * horizontal dilution of precision (HDOP), and retry-related fields for managing errors.
 *
 * **Fields:**
 * - `latitude`: Latitude in decimal degrees. Negative values indicate South.
 * - `longitude`: Longitude in decimal degrees. Negative values indicate West.
 * - `speed`: Speed over ground in meters per second.
 * - `time`: UTC time in HHMMSS.SS format.
 * - `fix_status`: GPS fix status (0 for no fix, 1 for fix acquired).
 * - `satellite_count`: Number of satellites used in the solution.
 * - `hdop`: Horizontal Dilution of Precision (lower is better; values < 1.0 are ideal).
 * - `state`: The current operational state of the GPS module (gy_neo6mv2_states_t).
 * - `retry_count`: The number of retry attempts after encountering an error.
 * - `retry_interval`: The current interval in ticks between retry attempts.
 * - `last_attempt_ticks`: The tick count of the last reinitialization attempt.
 */
typedef struct {
  float               latitude;           /**< GPS latitude in decimal degrees. Negative values indicate South. */
  float               longitude;          /**< GPS longitude in decimal degrees. Negative values indicate West. */
  float               speed;              /**< Speed over ground in meters per second. */
  char                time[11];           /**< UTC time in HHMMSS.SS format. */
  uint8_t             fix_status;         /**< GPS fix status (0: no fix, 1: fix acquired). */
  uint8_t             satellite_count;    /**< Number of satellites used in the solution. */
  float               hdop;               /**< Horizontal Dilution of Precision (accuracy measure; lower is better). */
  gy_neo6mv2_states_t state;              /**< Current operational state of the GPS module. */
  uint8_t             retry_count;        /**< Retry counter for managing exponential backoff. */
  uint32_t            retry_interval;     /**< Current retry interval in ticks. */
  TickType_t          last_attempt_ticks; /**< Tick count of the last reinitialization attempt. */
} gy_neo6mv2_data_t;

/**
 * @struct satellite_t
 * @brief Structure to store satellite information parsed from GPGSV sentences.
 *
 * This structure holds the details of a single satellite, including its identifier (PRN),
 * elevation, azimuth, and signal strength (SNR). The data is extracted from the GPGSV NMEA sentences.
 *
 * **Fields:**
 * - `prn`: Satellite's unique identifier (PRN - Pseudo Random Noise code).
 * - `elevation`: Satellite's elevation angle in degrees above the horizon.
 * - `azimuth`: Satellite's azimuth angle in degrees from true north.
 * - `snr`: Signal-to-Noise Ratio (SNR) indicating signal strength (0 to 99).
 */
typedef struct {
  uint8_t  prn;       /**< Satellite ID (PRN). */
  uint8_t  elevation; /**< Satellite elevation in degrees. */
  uint16_t azimuth;   /**< Satellite azimuth in degrees. */
  uint8_t  snr;       /**< Signal-to-Noise Ratio (SNR), 0-99. */
} satellite_t;

/* Public Functions ***********************************************************/

/**
 * @brief Convert GY-NEO6MV2 data to JSON.
 *
 * This function formats the GPS data stored in a `gy_neo6mv2_data_t` structure into a JSON string.
 * The JSON includes the sensor type, latitude, longitude, speed, and time.
 *
 * @param[in] data Pointer to `gy_neo6mv2_data_t` structure containing GPS data.
 *
 * @return Pointer to a dynamically allocated JSON string. The caller is responsible for freeing the memory.
 */
char *gy_neo6mv2_data_to_json(const gy_neo6mv2_data_t *data);

/**
 * @brief Initializes the GY-NEO6MV2 GPS module over UART.
 *
 * This function sets up the UART connection for communication with the GY-NEO6MV2 GPS module.
 * It configures the UART with the specified baud rate and establishes a connection between
 * the ESP32 and the GPS module. Upon successful initialization, the `gy_neo6mv2_data_t`
 * structure is prepared to receive GPS data.
 *
 * @param[in,out] sensor_data Pointer to the `gy_neo6mv2_data_t` structure to be initialized.
 *                            - Initializes GPS data fields and state.
 *
 * @return
 * - `ESP_OK` on successful initialization.
 * - An error code from the `esp_err_t` enumeration on failure.
 *
 * @note Call this function once during setup to initialize the GPS module for data acquisition.
 */
esp_err_t gy_neo6mv2_init(void *sensor_data);

/**
 * @brief Reads GPS data from the GY-NEO6MV2 GPS module.
 *
 * This function reads data from the GPS module over UART, processes NMEA sentences,
 * and updates the `gy_neo6mv2_data_t` structure with the latest GPS information.
 *
 * @param[in,out] sensor_data Pointer to `gy_neo6mv2_data_t` structure:
 *                            - `latitude`, `longitude`, `speed`, `time`, and `fix_status` are
 *                              updated with the latest GPS data (output).
 *                            - `state` is set to indicate a successful read or error (output).
 *
 * @return
 * - `ESP_OK` on successful read.
 * - `ESP_FAIL` on unsuccessful read.
 *
 * @note Ensure the GPS module is initialized using `gy_neo6mv2_init` before calling this function.
 */
esp_err_t gy_neo6mv2_read(gy_neo6mv2_data_t *sensor_data);

/**
 * @brief Manages error detection and recovery for the GY-NEO6MV2 GPS module using exponential backoff.
 *
 * This function checks the operational state of the GPS module and attempts to reinitialize it
 * if an error is detected. It uses an exponential backoff strategy to manage the retry intervals,
 * preventing excessive retries and allowing the module time to recover.
 *
 * @param[in,out] sensor_data Pointer to `gy_neo6mv2_data_t` structure:
 *                            - `state`: Current operational state (input/output).
 *                            - `retry_count`: Counter tracking reinitialization attempts (input/output).
 *                            - `retry_interval`: Current retry interval in ticks (input/output).
 *                            - `last_attempt_ticks`: Time of the last reinitialization attempt (input/output).
 *
 * @note This function should be periodically called within `gy_neo6mv2_tasks` to handle GPS errors and manage retries.
 */
void gy_neo6mv2_reset_on_error(gy_neo6mv2_data_t *sensor_data);

/**
 * @brief Periodically reads data from the GY-NEO6MV2 GPS module and manages errors.
 *
 * This function runs in a loop, continuously reading GPS data at intervals defined by
 * `gy_neo6mv2_polling_rate_ticks`. It handles errors by calling `gy_neo6mv2_reset_on_error`
 * to manage retries with an exponential backoff strategy. The function is designed to run
 * as a FreeRTOS task.
 *
 * @param[in,out] sensor_data Pointer to `gy_neo6mv2_data_t` structure for:
 *                            - GPS data fields (output).
 *                            - Retry-related fields for error handling (input/output).
 *
 * @note Run this function as part of a FreeRTOS task to ensure continuous GPS data acquisition and error management.
 */
void gy_neo6mv2_tasks(void *sensor_data);

#endif /* TOPOROBO_GY_NEO6MV2_HAL_H */

